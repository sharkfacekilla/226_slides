<!DOCTYPE html>
<html><head></head><body style="color: rgb(32, 33, 34); font-family: verdana, sans-serif; font-size: 12px;"><p>#!/usr/bin/python3.11</p>
<p>#<br># Write a Python3.11 TCP server that:<br># - receives 2 bytes over a network via port 11111,<br># - unpacks these 2 bytes as an unsigned short (let's call this value "sz")<br># - reads in a further "sz" bytes from the connection,<br># - ORs the "sz" bytes together<br># - sends the ORed result via the connection as a packed byte<br># - then closes the connection.<br># If an error occurs, the connection is closed, but the server must keep accepting new connections.<br>#<br># For example, the command echo '000401020408' | xxd -r -p | nc localhost 11111 | xxd -p returns 0f<br># This is because the input is equivalent to the following byte sequence:<br># 0004: 4 more bytes to read in<br># 01: 0000 0001<br># 02: 0000 0010<br># 04: 0000 0100<br># 08: 0000 1000<br># &nbsp; &nbsp; ---------<br># OR: 0000 1111 == 0f<br>#<br># Do NOT use threads or asyncio<br>#</p>
<p>from socket import socket, AF_INET, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR<br>from struct import pack, unpack</p>
<p>BUF_SIZE = 2<br>HOST = ''<br>PORT = 11111<br>QUEUE_SIZE = 1</p>
<p><br>def receive(sc, size):<br>&nbsp; &nbsp; data = b''<br>&nbsp; &nbsp; while len(data) &lt; size:<br>&nbsp; &nbsp; &nbsp; &nbsp; curr_data = sc.recv(size - len(data))<br>&nbsp; &nbsp; &nbsp; &nbsp; if curr_data == b'':<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return data</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; data += curr_data</p>
<p>&nbsp; &nbsp; return data</p>
<p><br>with socket(AF_INET, SOCK_STREAM) as sock:<br>&nbsp; &nbsp; sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)<br>&nbsp; &nbsp; sock.bind((HOST, PORT))<br>&nbsp; &nbsp; sock.listen(QUEUE_SIZE)<br>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; sc, _ = sock.accept()<br>&nbsp; &nbsp; &nbsp; &nbsp; try:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with sc:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = unpack('!H', receive(sc, BUF_SIZE))[0]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if sz &gt; 0:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = receive(sc, sz)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = 0<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i in range(sz):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = result | data[i]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sc.sendall(pack('!B', result))<br>&nbsp; &nbsp; &nbsp; &nbsp; except Exception as details:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(details)</p>
<p></p>
<hr>
<p></p>
<p>#!/usr/bin/python3.11</p>
<p>#<br># Write a Python3.11 TCP server that:<br># - receives 4 bytes over a network via port 22222,<br># - unpacks these 4 bytes as an unsigned integer (let's call this value "sz")<br># - reads in a further "sz" bytes from the connection,<br># - sends OK if the "sz" bytes are in strictly increasing order, NO otherwise<br># - then closes the connection.<br>#<br># For example, the command echo '00000004010214a8' | xxd -r -p | nc localhost 22222 returns OK<br># This is because the input is equivalent to the following byte sequence:<br># 00000004: 4 more bytes to read in<br># 01: 0000 0001 == 1<br># 02: 0000 0010 == 2<br># 14: 0001 0100 == 20<br># a8: 1010 1000 == 168<br># 1 &lt; 2 &lt; 20 &lt; 168, so the numbers are in strictly increasing order<br>#<br># However, echo '000000040102a814' | xxd -r -p | nc localhost 22222 would return NO because 168 appears before 20<br>#<br># Do NOT use threads or asyncio<br>#</p>
<p>from socket import socket, AF_INET, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR<br>from struct import pack, unpack</p>
<p>BUF_SIZE = 4<br>HOST = ''<br>PORT = 22222<br>QUEUE_SIZE = 1</p>
<p><br>def receive(sc, size):<br>&nbsp; &nbsp; data = b''<br>&nbsp; &nbsp; while len(data) &lt; size:<br>&nbsp; &nbsp; &nbsp; &nbsp; curr_data = sc.recv(size - len(data))<br>&nbsp; &nbsp; &nbsp; &nbsp; if curr_data == b'':<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return data</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; data += curr_data</p>
<p>&nbsp; &nbsp; return data</p>
<p><br>with socket(AF_INET, SOCK_STREAM) as sock:<br>&nbsp; &nbsp; sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)<br>&nbsp; &nbsp; sock.bind((HOST, PORT))<br>&nbsp; &nbsp; sock.listen(QUEUE_SIZE)<br>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; sc, _ = sock.accept()<br>&nbsp; &nbsp; &nbsp; &nbsp; with sc:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raw_sz = receive(sc, BUF_SIZE)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz = unpack('!I', raw_sz)[0]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if sz &gt; 0:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = 'OK\n'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = receive(sc, sz)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = -1<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i in range(sz):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if prev &gt;= data[i]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = 'NO\n'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = data[i]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sc.sendall(result.encode())</p>
<p></p>
<hr>
<p></p>
<p>#!/usr/bin/python3.11</p>
<p>#<br># Using Python3.11 threaded sockets, write a math game server that:<br># - starts a timer that prints out a random number in the range from 1 to 10, inclusive, every 10 seconds (use time.sleep(10)),<br># - adds that random number to a running total<br># - accepts any number of connections at port 33333,<br># - waits for answers from the clients (answers are in the form of newline-terminated strings that can be sent at any time; NO turns enforced; you can use nc localhost 33333 to launch a client),<br># - clients don't have to send an answer after every number announcement, but if they send an answer, it must match the server's running total<br># - clients can send the same answer multiple times<br># - if correct, "OK" is sent by the server<br># - an incorrect answer causes the server to send "NO" to the client, followed by a closure of that connection<br># - every 10 seconds, the server must also print out each client ID and the number of correct answers by that client<br>#<br># For example, say the server has started and printed out 7, then 10 seconds later, prints out a 1.<br># Let's say clients 1 and 2 connect. &nbsp;If either or them sends a message to the server, it must be an 8 (because 7 + 1 == 8), and it must be processed before the server announces the next random number.<br>#<br># See the screencast for a sample run.<br>#</p>
<p>from socket import socket, AF_INET, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR<br>from threading import Semaphore, Thread<br>from time import sleep<br>from random import randint</p>
<p>HOST = ''<br>INTERVAL = 10<br>PORT = 33333<br>QUEUE_SIZE = 1</p>
<p>lock = Semaphore()<br>ttl = 0<br>clients = {}</p>
<p><br>def get_line(current_socket: socket) -&gt; bytes:<br>&nbsp; &nbsp; buffer = b''<br>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; data = current_socket.recv(1)<br>&nbsp; &nbsp; &nbsp; &nbsp; if data == b'' or data == b'\n':<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return buffer<br>&nbsp; &nbsp; &nbsp; &nbsp; buffer = buffer + data</p>
<p><br>def announce_num():<br>&nbsp; &nbsp; global ttl, clients</p>
<p>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; num = randint(1,10)<br>&nbsp; &nbsp; &nbsp; &nbsp; with lock:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ttl += num<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(clients)<br>&nbsp; &nbsp; &nbsp; &nbsp; print(num)<br>&nbsp; &nbsp; &nbsp; &nbsp; sleep(10)</p>
<p><br>def listen_to_client(sc, client_id):<br>&nbsp; &nbsp; global ttl, lock</p>
<p>&nbsp; &nbsp; with sc:<br>&nbsp; &nbsp; &nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = int(get_line(sc))<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except ValueError:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with lock:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if data != ttl:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clients[client_id] = clients.get(client_id, 0) + 1<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sc.sendall('OK\n'.encode())<br>&nbsp; &nbsp; &nbsp; &nbsp; sc.sendall('NO\n'.encode())</p>
<p><br>with socket(AF_INET, SOCK_STREAM) as sock:<br>&nbsp; &nbsp; sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)<br>&nbsp; &nbsp; sock.bind((HOST, PORT))<br>&nbsp; &nbsp; sock.listen(QUEUE_SIZE)<br>&nbsp; &nbsp; Thread(target=announce_num).start()<br>&nbsp; &nbsp; num_clients = 0<br>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; client_socket, _ = sock.accept()<br>&nbsp; &nbsp; &nbsp; &nbsp; num_clients += 1<br>&nbsp; &nbsp; &nbsp; &nbsp; Thread(target=listen_to_client, args=(client_socket, num_clients)).start()</p>
<p></p>
<hr>
<p></p>
<p>#!/usr/bin/python3.11</p>
<p>#<br># Using Python3.11 threaded sockets, write a math game server that:<br># - starts a timer that prints out a random number in the range from 1 to 100, inclusive, every 5 seconds (use time.sleep(10)),<br># - determines whether or not that number is divisible by 3<br># - accepts any number of connections at port 55555,<br># - waits for answers from the clients (answers are in the form of newline-terminated strings that can be sent at any time; NO turns enforced; you can use nc localhost 55555 to launch a client),<br># - clients don't have to send an answer after every number announcement, but if they send an answer, it must be "ok" if the number is divisible by 3, "no" otherwise<br># - clients can send the same answer multiple times<br># - if correct, "OK" is sent by the server<br># - an incorrect answer causes the server to send "NO" to the client, followed by a closure of that connection<br># - every 5 seconds, the server must also print out each client ID and the number of correct answers by that client<br>#<br># For example, say the server has started and printed out a 21<br># Let's say clients 1 and 2 connect. &nbsp;If either or them sends a message to the server, it must be an "ok" (because 21 is divisible by 3), and the answer must be processed before the server announces the next random number.<br>#<br># See the screencast for a sample run.<br>#</p>
<p>from socket import socket, AF_INET, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR<br>from threading import Semaphore, Thread<br>from time import sleep<br>from random import randint</p>
<p>HOST = ''<br>INTERVAL = 5<br>PORT = 55555<br>QUEUE_SIZE = 1</p>
<p>lock = Semaphore()<br>div = False<br>clients = {}</p>
<p><br>def get_line(current_socket: socket) -&gt; bytes:<br>&nbsp; &nbsp; buffer = b''<br>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; data = current_socket.recv(1)<br>&nbsp; &nbsp; &nbsp; &nbsp; if data == b'' or data == b'\n':<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return buffer<br>&nbsp; &nbsp; &nbsp; &nbsp; buffer = buffer + data</p>
<p><br>def announce_num():<br>&nbsp; &nbsp; global div, clients</p>
<p>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; num = randint(1,100)<br>&nbsp; &nbsp; &nbsp; &nbsp; with lock:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; div = ((num % 3) == 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(clients)<br>&nbsp; &nbsp; &nbsp; &nbsp; print(num)<br>&nbsp; &nbsp; &nbsp; &nbsp; sleep(10)</p>
<p><br>def listen_to_client(sc, client_id):<br>&nbsp; &nbsp; global ttl, lock</p>
<p>&nbsp; &nbsp; with sc:<br>&nbsp; &nbsp; &nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = get_line(sc)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except ValueError:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with lock:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (div and data == b'no') or ((not div) and data == b'ok'):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clients[client_id] = clients.get(client_id, 0) + 1<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sc.sendall('OK\n'.encode())<br>&nbsp; &nbsp; &nbsp; &nbsp; sc.sendall('NO\n'.encode())</p>
<p><br>with socket(AF_INET, SOCK_STREAM) as sock:<br>&nbsp; &nbsp; sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)<br>&nbsp; &nbsp; sock.bind((HOST, PORT))<br>&nbsp; &nbsp; sock.listen(QUEUE_SIZE)<br>&nbsp; &nbsp; Thread(target=announce_num).start()<br>&nbsp; &nbsp; num_clients = 0<br>&nbsp; &nbsp; while True:<br>&nbsp; &nbsp; &nbsp; &nbsp; client_socket, _ = sock.accept()<br>&nbsp; &nbsp; &nbsp; &nbsp; num_clients += 1<br>&nbsp; &nbsp; &nbsp; &nbsp; Thread(target=listen_to_client, args=(client_socket, num_clients)).start()</p>
<p></p></body></html>